# 红岩暑假作业

简单虚拟机

实现的简单的四则运算以及取模，模拟栈内存存储数据，模拟二进制，利用寄存器控制指令调用，文件输入输出

|      |            |
| ---- | ---------- |
| PSH  | 数据压栈   |
| ADD  | 加法       |
| POP  | 打印       |
| SET  | 寄存器赋值 |
| HLT  | 结束       |
| MUL  | 乘法       |
| DIV  | 除法       |
| MOD  | 取模       |
| XOR  | 异或       |
| OR   | 或         |
| AND  | 与         |



### 如何使用

这里有一个实例的汇编（当然不是真的汇编，我会个锤子汇编

大致阐明了一些指令

使用程序的时候，在第一个参数是要调用的汇编文件，生成的out.txt就是输出文件了

### 内存

算是存在的问题之一，其实设计之初本质上是一个栈内存，存在一个压栈的操作

但是到后面用二进制重新设计加法器的时候，压栈就很不灵魂了

能在这里面看到释放的栈空间又重新跑回来的神奇情况

### 那么压栈呢

是通过PSH实现，用寄存器的sp来控制

输入数据压入 sp++

取出时 sp--

### 我可以控制指令集的流向吗，就像goto一样

理论上是可以的，SET提供了更改寄存器的可能性，寄存器的PC，就是确定目前指令的地址的

但是这个汇编没有条件判定，如果往前更改，只会形成死循环

### 用二进制来实现运算

lv4里面说的是我们模拟的数据是十进制的，和实际的硬件不匹配，确实，实际的硬件没有自带+-这类的计算

所以我这里想来实现模拟二进制，具体参考了电路里面的加法器，并没有简单的二进制转换

因为你程序本身也是二进制放进去的，只需要让这个计算全是逻辑电路就行（即位与 位或 求反 异或）

加法器依赖两个逻辑，异或和与

这两个分别代表这一位和下一位

用两个这样的东西连在一起就成了全加器，循环往复就实现了加法

通过对加法的补位就能实现减法

对加法的循环就是乘法

对减法的循环就是除法

所以这里又出现了几个存在的问题，没能在汇编实现循环（LOOP），加法器的构造还可以更快，循环不是逻辑电路

### 这样的汇编和真的汇编差了多少呢

我之前一直在看关于LC-3的实现，他读取汇编的方式和我设计的方式很有区别

其实看主函数就可以知道，这个程序自己是“不知道”什么是一句话的，我将每一个数分离出来，分别压入指令地址中

例如PSH 3，在地址中是以0 3 这样存储的（即二进制的0000  0011），而LC-3是用等长（x86不是等长）的16bit存储的，左边四个位是操作码，后面的是参数，这就构成了一句话。







毛毓珑 2019215155

2020/7/10